2014-12-31T10:24:58.094Z - debug: rti event interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=993, run_id=38e846e2bc5caec67313a8c6d7be176e85a91b40, tcp_port=6379, uptime_in_seconds=177194, uptime_in_days=2, hz=10, lru_clock=10735354, config_file=/usr/local/etc/redis.conf, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1005040, used_memory_human=981.48K, used_memory_rss=528384, used_memory_peak=1055600, used_memory_peak_human=1.01M, used_memory_lua=33792, mem_fragmentation_ratio=0.53, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1419844304, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=24, total_commands_processed=40, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=33.44, used_cpu_user=12.31, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, db0=keys=4,expires=0,avg_ttl=0, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021498094, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:24:58.113Z - debug: REDIS 已經建立.....事件被觸發
2014-12-31T10:24:58.371Z - debug: REDIS 已經建立.....事件被觸發
2014-12-31T10:27:33.150Z - debug: rti event interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=993, run_id=38e846e2bc5caec67313a8c6d7be176e85a91b40, tcp_port=6379, uptime_in_seconds=177349, uptime_in_days=2, hz=10, lru_clock=10735509, config_file=/usr/local/etc/redis.conf, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1005040, used_memory_human=981.48K, used_memory_rss=528384, used_memory_peak=1055600, used_memory_peak_human=1.01M, used_memory_lua=33792, mem_fragmentation_ratio=0.53, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1419844304, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=25, total_commands_processed=42, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=33.49, used_cpu_user=12.33, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, db0=keys=4,expires=0,avg_ttl=0, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021653150, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:27:33.169Z - debug: REDIS 已經建立.....事件被觸發
2014-12-31T10:27:33.599Z - debug: REDIS 已經建立.....事件被觸發
2014-12-31T10:27:45.251Z - debug: rti event interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=993, run_id=38e846e2bc5caec67313a8c6d7be176e85a91b40, tcp_port=6379, uptime_in_seconds=177361, uptime_in_days=2, hz=10, lru_clock=10735521, config_file=/usr/local/etc/redis.conf, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1005040, used_memory_human=981.48K, used_memory_rss=528384, used_memory_peak=1055600, used_memory_peak_human=1.01M, used_memory_lua=33792, mem_fragmentation_ratio=0.53, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1419844304, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=26, total_commands_processed=44, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=33.49, used_cpu_user=12.33, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, db0=keys=4,expires=0,avg_ttl=0, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021665250, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:27:45.282Z - debug: REDIS 已經建立.....事件被觸發
2014-12-31T10:27:45.527Z - debug: 自行建立一個新的 REDIS interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=32216, run_id=471494642c3754421a266e867ba8e6f2e136e908, tcp_port=9998, uptime_in_seconds=0, uptime_in_days=0, hz=10, lru_clock=10735521, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1003792, used_memory_human=980.27K, used_memory_rss=1376256, used_memory_peak=1003792, used_memory_peak_human=980.27K, used_memory_lua=33792, mem_fragmentation_ratio=1.37, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1420021665, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=1, total_commands_processed=2, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=0.00, used_cpu_user=0.00, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021665526, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:28:55.778Z - debug: rti event interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=993, run_id=38e846e2bc5caec67313a8c6d7be176e85a91b40, tcp_port=6379, uptime_in_seconds=177431, uptime_in_days=2, hz=10, lru_clock=10735591, config_file=/usr/local/etc/redis.conf, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1005040, used_memory_human=981.48K, used_memory_rss=528384, used_memory_peak=1055600, used_memory_peak_human=1.01M, used_memory_lua=33792, mem_fragmentation_ratio=0.53, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1419844304, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=27, total_commands_processed=46, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=33.52, used_cpu_user=12.34, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, db0=keys=4,expires=0,avg_ttl=0, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021735777, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:28:55.809Z - debug: REDIS 已經建立.....事件被觸發
2014-12-31T10:28:56.096Z - debug: rti event interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=993, run_id=38e846e2bc5caec67313a8c6d7be176e85a91b40, tcp_port=6379, uptime_in_seconds=177432, uptime_in_days=2, hz=10, lru_clock=10735592, config_file=/usr/local/etc/redis.conf, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1005040, used_memory_human=981.48K, used_memory_rss=532480, used_memory_peak=1055600, used_memory_peak_human=1.01M, used_memory_lua=33792, mem_fragmentation_ratio=0.53, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1419844304, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=28, total_commands_processed=48, instantaneous_ops_per_sec=1, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=33.52, used_cpu_user=12.34, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, db0=keys=4,expires=0,avg_ttl=0, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021736095, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:28:56.420Z - debug: REDIS 已經建立.....事件被觸發
2014-12-31T10:29:24.190Z - debug: rti event interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=993, run_id=38e846e2bc5caec67313a8c6d7be176e85a91b40, tcp_port=6379, uptime_in_seconds=177460, uptime_in_days=2, hz=10, lru_clock=10735620, config_file=/usr/local/etc/redis.conf, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1005040, used_memory_human=981.48K, used_memory_rss=532480, used_memory_peak=1055600, used_memory_peak_human=1.01M, used_memory_lua=33792, mem_fragmentation_ratio=0.53, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1419844304, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=29, total_commands_processed=50, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=33.53, used_cpu_user=12.35, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, db0=keys=4,expires=0,avg_ttl=0, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021764190, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:29:24.225Z - debug: REDIS 已經建立.....事件被觸發
2014-12-31T10:29:24.459Z - debug: 自行建立一個新的 REDIS interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=32306, run_id=65fbbf20fabe9d23460af0151208c008daa21527, tcp_port=9998, uptime_in_seconds=0, uptime_in_days=0, hz=10, lru_clock=10735620, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1003792, used_memory_human=980.27K, used_memory_rss=1343488, used_memory_peak=1003792, used_memory_peak_human=980.27K, used_memory_lua=33792, mem_fragmentation_ratio=1.34, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1420021764, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=1, total_commands_processed=2, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=0.00, used_cpu_user=0.00, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021764458, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:29:24.557Z - debug: rti event interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=993, run_id=38e846e2bc5caec67313a8c6d7be176e85a91b40, tcp_port=6379, uptime_in_seconds=177460, uptime_in_days=2, hz=10, lru_clock=10735620, config_file=/usr/local/etc/redis.conf, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1005040, used_memory_human=981.48K, used_memory_rss=532480, used_memory_peak=1055600, used_memory_peak_human=1.01M, used_memory_lua=33792, mem_fragmentation_ratio=0.53, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1419844304, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=30, total_commands_processed=52, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=33.53, used_cpu_user=12.35, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, db0=keys=4,expires=0,avg_ttl=0, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021764556, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:29:24.581Z - debug: REDIS 已經建立.....事件被觸發
2014-12-31T10:29:24.824Z - debug: 自行建立一個新的 REDIS interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=32326, run_id=6e42ca535782412b4429c11865e8871293114604, tcp_port=9998, uptime_in_seconds=0, uptime_in_days=0, hz=10, lru_clock=10735620, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1003792, used_memory_human=980.27K, used_memory_rss=1380352, used_memory_peak=1003792, used_memory_peak_human=980.27K, used_memory_lua=33792, mem_fragmentation_ratio=1.38, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1420021764, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=1, total_commands_processed=2, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=0.00, used_cpu_user=0.00, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021764824, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:30:26.862Z - debug: rti event interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=993, run_id=38e846e2bc5caec67313a8c6d7be176e85a91b40, tcp_port=6379, uptime_in_seconds=177522, uptime_in_days=2, hz=10, lru_clock=10735682, config_file=/usr/local/etc/redis.conf, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1004016, used_memory_human=980.48K, used_memory_rss=532480, used_memory_peak=1055600, used_memory_peak_human=1.01M, used_memory_lua=33792, mem_fragmentation_ratio=0.53, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1419844304, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=31, total_commands_processed=54, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=33.55, used_cpu_user=12.35, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, db0=keys=4,expires=0,avg_ttl=0, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021826861, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:30:26.927Z - debug: REDIS 已經建立.....事件被觸發
2014-12-31T10:30:27.334Z - debug: rti event interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=993, run_id=38e846e2bc5caec67313a8c6d7be176e85a91b40, tcp_port=6379, uptime_in_seconds=177523, uptime_in_days=2, hz=10, lru_clock=10735683, config_file=/usr/local/etc/redis.conf, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1004016, used_memory_human=980.48K, used_memory_rss=532480, used_memory_peak=1055600, used_memory_peak_human=1.01M, used_memory_lua=33792, mem_fragmentation_ratio=0.53, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1419844304, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=32, total_commands_processed=56, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=33.55, used_cpu_user=12.35, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, db0=keys=4,expires=0,avg_ttl=0, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021827333, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:30:27.728Z - debug: REDIS 已經建立.....事件被觸發
2014-12-31T10:31:09.073Z - debug: rti event interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=993, run_id=38e846e2bc5caec67313a8c6d7be176e85a91b40, tcp_port=6379, uptime_in_seconds=177565, uptime_in_days=2, hz=10, lru_clock=10735725, config_file=/usr/local/etc/redis.conf, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1004016, used_memory_human=980.48K, used_memory_rss=540672, used_memory_peak=1055600, used_memory_peak_human=1.01M, used_memory_lua=33792, mem_fragmentation_ratio=0.54, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1419844304, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=33, total_commands_processed=58, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=33.57, used_cpu_user=12.36, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, db0=keys=4,expires=0,avg_ttl=0, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021869072, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:31:09.103Z - debug: REDIS 已經建立.....事件被觸發
2014-12-31T10:31:09.864Z - debug: rti event interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=993, run_id=38e846e2bc5caec67313a8c6d7be176e85a91b40, tcp_port=6379, uptime_in_seconds=177565, uptime_in_days=2, hz=10, lru_clock=10735725, config_file=/usr/local/etc/redis.conf, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1004016, used_memory_human=980.48K, used_memory_rss=540672, used_memory_peak=1055600, used_memory_peak_human=1.01M, used_memory_lua=33792, mem_fragmentation_ratio=0.54, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1419844304, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=34, total_commands_processed=60, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=33.57, used_cpu_user=12.36, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, db0=keys=4,expires=0,avg_ttl=0, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021869863, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:31:10.241Z - debug: REDIS 已經建立.....事件被觸發
2014-12-31T10:31:32.323Z - debug: rti event interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=993, run_id=38e846e2bc5caec67313a8c6d7be176e85a91b40, tcp_port=6379, uptime_in_seconds=177588, uptime_in_days=2, hz=10, lru_clock=10735748, config_file=/usr/local/etc/redis.conf, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1004016, used_memory_human=980.48K, used_memory_rss=540672, used_memory_peak=1055600, used_memory_peak_human=1.01M, used_memory_lua=33792, mem_fragmentation_ratio=0.54, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1419844304, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=35, total_commands_processed=62, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=33.58, used_cpu_user=12.36, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, db0=keys=4,expires=0,avg_ttl=0, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021892323, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:31:32.351Z - debug: REDIS 已經建立.....事件被觸發
2014-12-31T10:31:32.834Z - debug: rti event interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=993, run_id=38e846e2bc5caec67313a8c6d7be176e85a91b40, tcp_port=6379, uptime_in_seconds=177588, uptime_in_days=2, hz=10, lru_clock=10735748, config_file=/usr/local/etc/redis.conf, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1004016, used_memory_human=980.48K, used_memory_rss=540672, used_memory_peak=1055600, used_memory_peak_human=1.01M, used_memory_lua=33792, mem_fragmentation_ratio=0.54, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1419844304, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=36, total_commands_processed=64, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=33.58, used_cpu_user=12.36, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, db0=keys=4,expires=0,avg_ttl=0, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021892833, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:31:32.842Z - debug: 自行建立一個新的 REDIS interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=32463, run_id=c53fbebd6e230d2710f8ae35ccc660710cd7f6d0, tcp_port=9998, uptime_in_seconds=0, uptime_in_days=0, hz=10, lru_clock=10735748, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1003792, used_memory_human=980.27K, used_memory_rss=1347584, used_memory_peak=1003792, used_memory_peak_human=980.27K, used_memory_lua=33792, mem_fragmentation_ratio=1.34, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1420021892, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=1, total_commands_processed=2, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=0.00, used_cpu_user=0.00, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021892841, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:31:33.283Z - debug: REDIS 已經建立.....事件被觸發
2014-12-31T10:31:39.211Z - debug: rti event interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=993, run_id=38e846e2bc5caec67313a8c6d7be176e85a91b40, tcp_port=6379, uptime_in_seconds=177595, uptime_in_days=2, hz=10, lru_clock=10735755, config_file=/usr/local/etc/redis.conf, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1004016, used_memory_human=980.48K, used_memory_rss=540672, used_memory_peak=1055600, used_memory_peak_human=1.01M, used_memory_lua=33792, mem_fragmentation_ratio=0.54, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1419844304, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=37, total_commands_processed=66, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=33.58, used_cpu_user=12.36, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, db0=keys=4,expires=0,avg_ttl=0, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021899210, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:31:39.247Z - debug: REDIS 已經建立.....事件被觸發
2014-12-31T10:31:39.492Z - debug: 自行建立一個新的 REDIS interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=32512, run_id=98ba54fd0450bcdec019e24633d296abb04eff47, tcp_port=9998, uptime_in_seconds=0, uptime_in_days=0, hz=10, lru_clock=10735755, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1003792, used_memory_human=980.27K, used_memory_rss=1376256, used_memory_peak=1003792, used_memory_peak_human=980.27K, used_memory_lua=33792, mem_fragmentation_ratio=1.37, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1420021899, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=1, total_commands_processed=2, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=0.00, used_cpu_user=0.00, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021899491, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:32:25.877Z - debug: rti event interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=993, run_id=38e846e2bc5caec67313a8c6d7be176e85a91b40, tcp_port=6379, uptime_in_seconds=177641, uptime_in_days=2, hz=10, lru_clock=10735801, config_file=/usr/local/etc/redis.conf, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1004016, used_memory_human=980.48K, used_memory_rss=540672, used_memory_peak=1055600, used_memory_peak_human=1.01M, used_memory_lua=33792, mem_fragmentation_ratio=0.54, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1419844304, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=38, total_commands_processed=68, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=33.60, used_cpu_user=12.37, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, db0=keys=4,expires=0,avg_ttl=0, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021945877, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:32:25.907Z - debug: REDIS 已經建立.....事件被觸發
2014-12-31T10:32:26.151Z - debug: 自行建立一個新的 REDIS interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=32547, run_id=e707b24baf22c63874378cb80722c3fdec16c093, tcp_port=9998, uptime_in_seconds=1, uptime_in_days=0, hz=10, lru_clock=10735802, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1003792, used_memory_human=980.27K, used_memory_rss=1347584, used_memory_peak=1003792, used_memory_peak_human=980.27K, used_memory_lua=33792, mem_fragmentation_ratio=1.34, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1420021945, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=1, total_commands_processed=2, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=0.00, used_cpu_user=0.00, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021946150, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:32:26.350Z - debug: rti event interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=993, run_id=38e846e2bc5caec67313a8c6d7be176e85a91b40, tcp_port=6379, uptime_in_seconds=177642, uptime_in_days=2, hz=10, lru_clock=10735802, config_file=/usr/local/etc/redis.conf, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1004016, used_memory_human=980.48K, used_memory_rss=544768, used_memory_peak=1055600, used_memory_peak_human=1.01M, used_memory_lua=33792, mem_fragmentation_ratio=0.54, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1419844304, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=39, total_commands_processed=70, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=33.60, used_cpu_user=12.37, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, db0=keys=4,expires=0,avg_ttl=0, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021946349, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:32:26.372Z - debug: REDIS 已經建立.....事件被觸發
2014-12-31T10:32:26.624Z - debug: 自行建立一個新的 REDIS interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=32567, run_id=fcbec8b383991e36bd2940bae125029401dabb4c, tcp_port=9998, uptime_in_seconds=0, uptime_in_days=0, hz=10, lru_clock=10735802, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1003792, used_memory_human=980.27K, used_memory_rss=1376256, used_memory_peak=1003792, used_memory_peak_human=980.27K, used_memory_lua=33792, mem_fragmentation_ratio=1.37, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1420021946, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=1, total_commands_processed=2, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=0.00, used_cpu_user=0.00, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021946623, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:32:59.564Z - debug: rti event interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=993, run_id=38e846e2bc5caec67313a8c6d7be176e85a91b40, tcp_port=6379, uptime_in_seconds=177675, uptime_in_days=2, hz=10, lru_clock=10735835, config_file=/usr/local/etc/redis.conf, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1004016, used_memory_human=980.48K, used_memory_rss=544768, used_memory_peak=1055600, used_memory_peak_human=1.01M, used_memory_lua=33792, mem_fragmentation_ratio=0.54, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1419844304, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=40, total_commands_processed=72, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=33.61, used_cpu_user=12.38, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, db0=keys=4,expires=0,avg_ttl=0, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021979563, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:32:59.595Z - debug: REDIS 已經建立.....事件被觸發
2014-12-31T10:33:00.171Z - debug: rti event interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=993, run_id=38e846e2bc5caec67313a8c6d7be176e85a91b40, tcp_port=6379, uptime_in_seconds=177676, uptime_in_days=2, hz=10, lru_clock=10735836, config_file=/usr/local/etc/redis.conf, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1004016, used_memory_human=980.48K, used_memory_rss=548864, used_memory_peak=1055600, used_memory_peak_human=1.01M, used_memory_lua=33792, mem_fragmentation_ratio=0.55, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1419844304, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=41, total_commands_processed=74, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=33.61, used_cpu_user=12.38, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, db0=keys=4,expires=0,avg_ttl=0, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021980171, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:33:00.180Z - debug: 自行建立一個新的 REDIS interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=32601, run_id=8325f7cca10bfd9bb3225b71c2f4b8b2568a5f14, tcp_port=9998, uptime_in_seconds=1, uptime_in_days=0, hz=10, lru_clock=10735836, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1003792, used_memory_human=980.27K, used_memory_rss=1363968, used_memory_peak=1003792, used_memory_peak_human=980.27K, used_memory_lua=33792, mem_fragmentation_ratio=1.36, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1420021979, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=1, total_commands_processed=2, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=0.00, used_cpu_user=0.00, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021980180, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:33:00.538Z - debug: REDIS 已經建立.....事件被觸發
2014-12-31T10:33:08.965Z - debug: rti event interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=993, run_id=38e846e2bc5caec67313a8c6d7be176e85a91b40, tcp_port=6379, uptime_in_seconds=177684, uptime_in_days=2, hz=10, lru_clock=10735844, config_file=/usr/local/etc/redis.conf, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1004016, used_memory_human=980.48K, used_memory_rss=548864, used_memory_peak=1055600, used_memory_peak_human=1.01M, used_memory_lua=33792, mem_fragmentation_ratio=0.55, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1419844304, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=42, total_commands_processed=76, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=33.61, used_cpu_user=12.38, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, db0=keys=4,expires=0,avg_ttl=0, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021988964, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:33:09.006Z - debug: REDIS 已經建立.....事件被觸發
2014-12-31T10:33:09.251Z - debug: 自行建立一個新的 REDIS interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=32650, run_id=cc6dcb0b75074c6f43bd4b05bed0e4001136ab3b, tcp_port=9998, uptime_in_seconds=0, uptime_in_days=0, hz=10, lru_clock=10735845, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1003792, used_memory_human=980.27K, used_memory_rss=1396736, used_memory_peak=1003792, used_memory_peak_human=980.27K, used_memory_lua=33792, mem_fragmentation_ratio=1.39, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1420021989, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=1, total_commands_processed=2, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=0.00, used_cpu_user=0.00, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420021989250, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:35:57.952Z - debug: rti event interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=993, run_id=38e846e2bc5caec67313a8c6d7be176e85a91b40, tcp_port=6379, uptime_in_seconds=177853, uptime_in_days=2, hz=10, lru_clock=10736013, config_file=/usr/local/etc/redis.conf, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1004016, used_memory_human=980.48K, used_memory_rss=548864, used_memory_peak=1055600, used_memory_peak_human=1.01M, used_memory_lua=33792, mem_fragmentation_ratio=0.55, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1419844304, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=43, total_commands_processed=78, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=33.67, used_cpu_user=12.40, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, db0=keys=4,expires=0,avg_ttl=0, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420022157951, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:35:57.980Z - debug: REDIS 已經建立.....事件被觸發
2014-12-31T10:35:58.225Z - debug: 自行建立一個新的 REDIS interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=32706, run_id=9a8e1fa3525b25309702d334fb0e437f5c3d5b5b, tcp_port=9998, uptime_in_seconds=1, uptime_in_days=0, hz=10, lru_clock=10736014, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1003792, used_memory_human=980.27K, used_memory_rss=1343488, used_memory_peak=1003792, used_memory_peak_human=980.27K, used_memory_lua=33792, mem_fragmentation_ratio=1.34, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1420022157, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=1, total_commands_processed=2, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=0.00, used_cpu_user=0.00, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420022158224, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:35:58.429Z - debug: rti event interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=993, run_id=38e846e2bc5caec67313a8c6d7be176e85a91b40, tcp_port=6379, uptime_in_seconds=177854, uptime_in_days=2, hz=10, lru_clock=10736014, config_file=/usr/local/etc/redis.conf, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1004016, used_memory_human=980.48K, used_memory_rss=548864, used_memory_peak=1055600, used_memory_peak_human=1.01M, used_memory_lua=33792, mem_fragmentation_ratio=0.55, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1419844304, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=44, total_commands_processed=80, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=33.67, used_cpu_user=12.40, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, db0=keys=4,expires=0,avg_ttl=0, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420022158429, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:35:58.448Z - debug: REDIS 已經建立.....事件被觸發
2014-12-31T10:35:58.698Z - debug: 自行建立一個新的 REDIS interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=32726, run_id=72642a365a73e333e1fb031865b2021b7da497a0, tcp_port=9998, uptime_in_seconds=0, uptime_in_days=0, hz=10, lru_clock=10736014, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1003792, used_memory_human=980.27K, used_memory_rss=1347584, used_memory_peak=1003792, used_memory_peak_human=980.27K, used_memory_lua=33792, mem_fragmentation_ratio=1.34, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1420022158, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=1, total_commands_processed=2, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=0.00, used_cpu_user=0.00, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420022158697, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:36:26.541Z - debug: rti event interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=993, run_id=38e846e2bc5caec67313a8c6d7be176e85a91b40, tcp_port=6379, uptime_in_seconds=177882, uptime_in_days=2, hz=10, lru_clock=10736042, config_file=/usr/local/etc/redis.conf, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1004016, used_memory_human=980.48K, used_memory_rss=548864, used_memory_peak=1055600, used_memory_peak_human=1.01M, used_memory_lua=33792, mem_fragmentation_ratio=0.55, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1419844304, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=45, total_commands_processed=82, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=33.68, used_cpu_user=12.40, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, db0=keys=4,expires=0,avg_ttl=0, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420022186540, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:36:26.582Z - debug: REDIS 已經建立.....事件被觸發
2014-12-31T10:36:26.813Z - debug: 自行建立一個新的 REDIS interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=32752, run_id=7e3594de7d6957cec14c2de0d645ed65349b4718, tcp_port=9998, uptime_in_seconds=0, uptime_in_days=0, hz=10, lru_clock=10736042, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1003792, used_memory_human=980.27K, used_memory_rss=1363968, used_memory_peak=1003792, used_memory_peak_human=980.27K, used_memory_lua=33792, mem_fragmentation_ratio=1.36, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1420022186, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=1, total_commands_processed=2, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=0.00, used_cpu_user=0.00, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420022186812, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:36:27.113Z - debug: rti event interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=993, run_id=38e846e2bc5caec67313a8c6d7be176e85a91b40, tcp_port=6379, uptime_in_seconds=177883, uptime_in_days=2, hz=10, lru_clock=10736043, config_file=/usr/local/etc/redis.conf, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1004016, used_memory_human=980.48K, used_memory_rss=548864, used_memory_peak=1055600, used_memory_peak_human=1.01M, used_memory_lua=33792, mem_fragmentation_ratio=0.55, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1419844304, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=46, total_commands_processed=84, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=33.68, used_cpu_user=12.40, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, db0=keys=4,expires=0,avg_ttl=0, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420022187112, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:36:27.131Z - debug: REDIS 已經建立.....事件被觸發
2014-12-31T10:36:27.216Z - debug: rti event interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=993, run_id=38e846e2bc5caec67313a8c6d7be176e85a91b40, tcp_port=6379, uptime_in_seconds=177883, uptime_in_days=2, hz=10, lru_clock=10736043, config_file=/usr/local/etc/redis.conf, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1004016, used_memory_human=980.48K, used_memory_rss=548864, used_memory_peak=1055600, used_memory_peak_human=1.01M, used_memory_lua=33792, mem_fragmentation_ratio=0.55, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1419844304, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=47, total_commands_processed=86, instantaneous_ops_per_sec=1, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=33.68, used_cpu_user=12.40, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, db0=keys=4,expires=0,avg_ttl=0, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420022187216, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:36:27.229Z - debug: 自行建立一個新的 REDIS interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=32772, run_id=3dd2364f19388e2b154191953a80ef65f895189e, tcp_port=9998, uptime_in_seconds=0, uptime_in_days=0, hz=10, lru_clock=10736043, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1003792, used_memory_human=980.27K, used_memory_rss=1335296, used_memory_peak=1003792, used_memory_peak_human=980.27K, used_memory_lua=33792, mem_fragmentation_ratio=1.33, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1420022187, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=1, total_commands_processed=2, instantaneous_ops_per_sec=0, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=0.00, used_cpu_user=0.00, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"], _idleStart=1420022187228, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:36:28.835Z - debug: rti event interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=993, run_id=38e846e2bc5caec67313a8c6d7be176e85a91b40, tcp_port=6379, uptime_in_seconds=177884, uptime_in_days=2, hz=10, lru_clock=10736044, config_file=/usr/local/etc/redis.conf, connected_clients=1, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1004016, used_memory_human=980.48K, used_memory_rss=552960, used_memory_peak=1055600, used_memory_peak_human=1.01M, used_memory_lua=33792, mem_fragmentation_ratio=0.55, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1419844304, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=48, total_commands_processed=88, instantaneous_ops_per_sec=2, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=33.68, used_cpu_user=12.40, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, db0=keys=4,expires=0,avg_ttl=0, _idleTimeout=10000, $ref=$["intervalId"], _idleTimeout=10000, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"]["_idlePrev"]["_idlePrev"], _idleStart=1420022187605, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[], $ref=$["intervalId"]["_idlePrev"], _idleStart=1420022187228, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, $ref=$["intervalId"]["_idlePrev"]["_idlePrev"]["_idlePrev"]["domain"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"]["_idlePrev"]["_idlePrev"], _idleStart=1420022188835, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:36:28.842Z - debug: 自行建立一個新的 REDIS interval=10000, redis_version=2.8.9, redis_git_sha1=00000000, redis_git_dirty=0, redis_build_id=9ccc8119ea98f6e1, redis_mode=standalone, os=Darwin 14.0.0 x86_64, arch_bits=64, multiplexing_api=kqueue, gcc_version=4.2.1, process_id=32781, run_id=bfaf626890094f5105cfb6815495b33803768210, tcp_port=9998, uptime_in_seconds=1, uptime_in_days=0, hz=10, lru_clock=10736044, connected_clients=2, client_longest_output_list=0, client_biggest_input_buf=0, blocked_clients=0, used_memory=1021088, used_memory_human=997.16K, used_memory_rss=1449984, used_memory_peak=1021088, used_memory_peak_human=997.16K, used_memory_lua=33792, mem_fragmentation_ratio=1.42, mem_allocator=libc, loading=0, rdb_changes_since_last_save=0, rdb_bgsave_in_progress=0, rdb_last_save_time=1420022187, rdb_last_bgsave_status=ok, rdb_last_bgsave_time_sec=-1, rdb_current_bgsave_time_sec=-1, aof_enabled=0, aof_rewrite_in_progress=0, aof_rewrite_scheduled=0, aof_last_rewrite_time_sec=-1, aof_current_rewrite_time_sec=-1, aof_last_bgrewrite_status=ok, aof_last_write_status=ok, total_connections_received=2, total_commands_processed=5, instantaneous_ops_per_sec=1, rejected_connections=0, sync_full=0, sync_partial_ok=0, sync_partial_err=0, expired_keys=0, evicted_keys=0, keyspace_hits=0, keyspace_misses=0, pubsub_channels=0, pubsub_patterns=0, latest_fork_usec=0, role=master, connected_slaves=0, master_repl_offset=0, repl_backlog_active=0, repl_backlog_size=1048576, repl_backlog_first_byte_offset=0, repl_backlog_histlen=0, used_cpu_sys=0.00, used_cpu_user=0.00, used_cpu_sys_children=0.00, used_cpu_user_children=0.00, _idleTimeout=10000, $ref=$["intervalId"], _idleTimeout=10000, _idleTimeout=10000, $ref=$["intervalId"], $ref=$["intervalId"]["_idlePrev"]["_idlePrev"], _idleStart=1420022187605, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[], $ref=$["intervalId"]["_idlePrev"], _idleStart=1420022187228, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, $ref=$["intervalId"]["_idlePrev"]["_idlePrev"]["_idlePrev"]["domain"], msecs=10000, ontimeout=function listOnTimeout() {
  var msecs = this.msecs;
  var list = this;

  debug('timeout callback ' + msecs);

  var now = Date.now();
  debug('now: ' + now);

  var first;
  while (first = L.peek(list)) {
    var diff = now - first._idleStart;
    if (diff < msecs) {
      list.start(msecs - diff, 0);
      debug(msecs + ' list wait because diff is ' + diff);
      return;
    } else {
      L.remove(first);
      assert(first !== L.peek(list));

      if (!first._onTimeout) continue;

      // v0.4 compatibility: if the timer callback throws and the
      // domain or uncaughtException handler ignore the exception,
      // other timers that expire on this tick should still run.
      //
      // https://github.com/joyent/node/issues/2631
      var domain = first.domain;
      if (domain && domain._disposed) continue;
      try {
        if (domain)
          domain.enter();
        var threw = true;
        first._onTimeout();
        if (domain)
          domain.exit();
        threw = false;
      } finally {
        if (threw) {
          process.nextTick(function() {
            list.ontimeout();
          });
        }
      }
    }
  }

  debug(msecs + ' list empty');
  assert(L.isEmpty(list));
  list.close();
  delete lists[msecs];
}, $ref=$["intervalId"]["_idlePrev"]["_idlePrev"]["_idlePrev"], _idleStart=1420022188841, _onTimeout=function wrapper() {
    callback.apply(this, args);
    // If callback called clearInterval().
    if (timer._repeat === false) return;
    // If timer is unref'd (or was - it's permanently removed from the list.)
    if (this._handle) {
      this._handle.start(repeat, 0);
    } else {
      timer._idleTimeout = repeat;
      exports.active(timer);
    }
  }, _repeat=true, domain=null, error=function handleException(err) {
			if (err.name === 'AssertionError' && runner) {
				runner.uncaught(err);
			} else {
				clearCache();
				stream.emit('error', new gutil.PluginError('gulp-mocha', err, {stack: err.stack, showStack: true}));
			}
		}, _maxListeners=10, members=[]
2014-12-31T10:36:29.178Z - debug: REDIS 已經建立.....事件被觸發
2014-12-31T10:36:29.185Z - debug: REDIS 已經建立.....事件被觸發
